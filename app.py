import os
import subprocess
import uuid
import re
from pathlib import Path
from datetime import datetime
from flask import (
    Flask, request, render_template, send_from_directory,
    flash, redirect, url_for, jsonify
)
from werkzeug.utils import secure_filename
import docx
import ebooklib
from ebooklib import epub
from bs4 import BeautifulSoup
from celery import Celery, Task
import fitz  # PyMuPDF
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, TIT2, TPE1, TALB, COMM  # For MP3 tagging

from tts_service import TTSService

# --- Configuration ---
UPLOAD_FOLDER = '/app/uploads'
GENERATED_FOLDER = '/app/generated'
VOICES_FOLDER = '/app/voices'
ALLOWED_EXTENSIONS = {'txt', 'pdf', 'docx', 'epub'}

# --- Flask App Initialization ---
app = Flask(__name__)
app.config.from_mapping(
    UPLOAD_FOLDER=UPLOAD_FOLDER,
    GENERATED_FOLDER=GENERATED_FOLDER,
    SECRET_KEY='a-secure-and-random-secret-key'
)

# --- Celery Configuration ---
def celery_init_app(app: Flask) -> Celery:
    class FlaskTask(Task):
        def __call__(self, *args: object, **kwargs: object) -> object:
            with app.app_context():
                return self.run(*args, **kwargs)

    celery_app = Celery(app.name, task_cls=FlaskTask)
    celery_app.config_from_object("celery_config")
    return celery_app

celery = celery_init_app(app)

# --- Ensure Directories Exist ---
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(GENERATED_FOLDER, exist_ok=True)


# --- Helper Functions ---
def allowed_file(filename):
    """Check if the uploaded file has an allowed extension."""
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def tag_mp3_file(filepath, metadata):
    """Adds ID3 metadata tags to the generated MP3 file correctly."""
    try:
        audio = MP3(filepath)

        # Add an ID3 tag header if the file doesn't have one
        if audio.tags is None:
            audio.add_tags()
        
        title = metadata.get('title', 'Unknown Title')
        author = metadata.get('author', 'Unknown Author')
        
        audio.tags.add(TIT2(encoding=3, text=title))
        audio.tags.add(TPE1(encoding=3, text=author))
        audio.tags.add(TALB(encoding=3, text=title)) # Use title for Album as well
        audio.tags.add(COMM(encoding=3, lang='eng', desc='Comment', text='Generated by Docket TTS'))
        
        audio.save()
        app.logger.info(f"Successfully tagged {filepath}")
    except Exception as e:
        app.logger.error(f"Failed to tag {filepath}: {e}")

def parse_metadata_from_text(text_content):
    """Scans the beginning of text to find Title and Author as a fallback."""
    parsed_meta = {}
    search_area = text_content[:4000]
    lines = [line.strip() for line in search_area.split('\n') if line.strip()]

    if not lines:
        return parsed_meta

    for line in lines:
        if line.lower().startswith('by '):
            author = line[3:].strip()
            if 2 < len(author) < 60:
                parsed_meta['author'] = author
                break

    potential_titles = []
    for line in lines[:15]:
        if 'author' in parsed_meta and parsed_meta['author'] in line:
            continue
        
        words = line.split()
        if 1 < len(words) < 12:
            if line.isupper():
                potential_titles.append((line, len(line) + 20))
            else:
                potential_titles.append((line, len(line)))

    if potential_titles:
        best_title = sorted(potential_titles, key=lambda x: x[1], reverse=True)[0][0]
        parsed_meta['title'] = best_title

    return parsed_meta

def extract_text_and_metadata(filepath):
    """
    Extracts text and metadata from files, using text parsing as a fallback.
    """
    p_filepath = Path(filepath)
    extension = p_filepath.suffix.lower()
    text = ""
    metadata = {'title': p_filepath.stem.replace('_', ' ').title(), 'author': 'Unknown'}

    try:
        if extension == '.pdf':
            cleaned_filepath = f"{filepath}.cleaned.pdf"
            gs_command = ['gs', '-sDEVICE=pdfwrite', '-dCompatibilityLevel=1.7', '-dNOPAUSE', '-dBATCH', f'-sOutputFile={cleaned_filepath}', filepath]
            subprocess.run(gs_command, check=True, capture_output=True)
            
            with fitz.open(cleaned_filepath) as doc:
                doc_meta = doc.metadata
                if doc_meta:
                    metadata['title'] = doc_meta.get('title') or metadata['title']
                    metadata['author'] = doc_meta.get('author') or metadata['author']
                for page in doc:
                    text += page.get_text() + "\n"
            os.remove(cleaned_filepath)

        elif extension == '.docx':
            doc = docx.Document(filepath)
            if doc.core_properties:
                metadata['title'] = doc.core_properties.title or metadata['title']
                metadata['author'] = doc.core_properties.author or metadata['author']
            text = "\n".join([para.text for para in doc.paragraphs])
            
        elif extension == '.epub':
            book = epub.read_epub(filepath)
            titles = book.get_metadata('DC', 'title')
            if titles: metadata['title'] = titles[0][0]
            creators = book.get_metadata('DC', 'creator')
            if creators: metadata['author'] = creators[0][0]
                
            for item in book.get_items_of_type(ebooklib.ITEM_DOCUMENT):
                soup = BeautifulSoup(item.get_body_content(), 'html.parser')
                text += soup.get_text() + "\n\n"
        
        elif extension == '.txt':
            text = p_filepath.read_text(encoding='utf-8')

    except Exception as e:
        app.logger.error(f"Error extracting from {filepath}: {e}")
        if 'cleaned_filepath' in locals() and os.path.exists(cleaned_filepath):
            os.remove(cleaned_filepath)
        return None, None
        
    if text:
        parsed_meta = parse_metadata_from_text(text)
        if metadata['title'] == p_filepath.stem.replace('_', ' ').title() and 'title' in parsed_meta:
            metadata['title'] = parsed_meta['title']
        if metadata['author'] == 'Unknown' and 'author' in parsed_meta:
            metadata['author'] = parsed_meta['author']
            
    if not metadata['title']: metadata['title'] = p_filepath.stem.replace('_', ' ').title()
    if not metadata['author']: metadata['author'] = 'Unknown'

    return text, metadata

def list_available_voices():
    voices = []
    voice_dir = Path(VOICES_FOLDER)
    if voice_dir.is_dir():
        for voice_file in voice_dir.glob("*.onnx"):
            voices.append({"id": voice_file.name, "name": voice_file.stem})
    return sorted(voices, key=lambda v: v['name'])

@celery.task(bind=True)
def convert_to_speech_task(self, input_filepath, original_filename, voice_name=None):
    """Background task that extracts text/metadata, synthesizes, and tags the MP3."""
    try:
        self.update_state(state='PROGRESS', meta={'current': 1, 'total': 4, 'status': 'Extracting text and metadata...'})
        text_content, metadata = extract_text_and_metadata(input_filepath)
        if not text_content or not metadata:
            raise ValueError('Could not extract text or metadata from the file.')

        self.update_state(state='PROGRESS', meta={'current': 2, 'total': 4, 'status': 'Synthesizing audio...'})
        unique_id = str(uuid.uuid4().hex[:8])
        base_name = Path(original_filename).stem
        output_filename = f"{base_name}_{unique_id}.mp3"
        output_filepath = os.path.join(GENERATED_FOLDER, output_filename)
        
        tts = TTSService(voice=voice_name)
        _, normalized_text = tts.synthesize(text_content, output_filepath)

        self.update_state(state='PROGRESS', meta={'current': 3, 'total': 4, 'status': 'Tagging audio file...'})
        tag_mp3_file(output_filepath, metadata)

        self.update_state(state='PROGRESS', meta={'current': 4, 'total': 4, 'status': 'Saving text file...'})
        text_filename = f"{base_name}_{unique_id}.txt"
        text_filepath = os.path.join(GENERATED_FOLDER, text_filename)
        Path(text_filepath).write_text(normalized_text, encoding="utf-8")

        return {'status': 'Success', 'filename': output_filename, 'textfile': text_filename}
    except Exception as e:
        app.logger.error(f"TTS Conversion failed in task {self.request.id}: {e}")
        self.update_state(state='FAILURE', meta={'exc_type': type(e).__name__, 'exc_message': str(e)})
        raise e

@app.route('/', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        if 'file' not in request.files:
            flash('No file part in the request.', 'error')
            return redirect(request.url)
        file = request.files['file']
        if file.filename == '' or not allowed_file(file.filename):
            flash('Invalid file. Please select a TXT, DOCX, EPUB, or PDF file.', 'error')
            return redirect(request.url)

        original_filename = secure_filename(file.filename)
        input_filepath = os.path.join(app.config['UPLOAD_FOLDER'], original_filename)
        file.save(input_filepath)

        voice_name = request.form.get("voice")
        task = convert_to_speech_task.delay(input_filepath, original_filename, voice_name)
        return render_template('result.html', task_id=task.id)

    voices = list_available_voices()
    return render_template('index.html', voices=voices)

@app.route('/files')
def list_files():
    paired_files = {}
    with os.scandir(GENERATED_FOLDER) as it:
        for entry in it:
            if entry.is_file() and not entry.name.startswith('sample_'):
                base_name = Path(entry.name).stem
                if base_name not in paired_files:
                    paired_files[base_name] = {'base_name': base_name}
                if entry.name.endswith('.mp3'):
                    paired_files[base_name]['mp3'] = entry.name
                    mod_time = datetime.fromtimestamp(entry.stat().st_mtime)
                    paired_files[base_name]['date'] = mod_time.strftime('%Y-%m-%d %H:%M')
                elif entry.name.endswith('.txt'):
                    paired_files[base_name]['txt'] = entry.name
    file_pairs = sorted([v for k, v in paired_files.items() if 'mp3' in v], key=lambda p: p['date'], reverse=True)
    return render_template('files.html', file_pairs=file_pairs)

@app.route('/delete-bulk', methods=['POST'])
def delete_bulk():
    files_to_delete = request.form.getlist('files_to_delete')
    if not files_to_delete:
        flash("No files selected for deletion.", "warning")
        return redirect(url_for('list_files'))

    deleted_count = 0
    for base_name in files_to_delete:
        safe_base_name = secure_filename(base_name)
        mp3_path = Path(GENERATED_FOLDER) / f"{safe_base_name}.mp3"
        txt_path = Path(GENERATED_FOLDER) / f"{safe_base_name}.txt"
        if mp3_path.exists() and mp3_path.is_file():
            mp3_path.unlink()
            deleted_count += 1
        if txt_path.exists() and txt_path.is_file():
            txt_path.unlink()
    flash(f"Successfully deleted {deleted_count} file pair(s).", "success")
    return redirect(url_for('list_files'))

@app.route('/speak_sample/<voice_name>')
def speak_sample(voice_name):
    sample_text = "This is a sample of my voice."
    filename = f"sample_{Path(voice_name).stem}.mp3"
    filepath = os.path.join(GENERATED_FOLDER, filename)
    if not os.path.exists(filepath):
        try:
            tts = TTSService(voice=voice_name)
            tts.synthesize(sample_text, filepath)
        except Exception as e:
            return f"Error generating sample: {e}", 500
    return send_from_directory(app.config["GENERATED_FOLDER"], filename)

@app.route('/status/<task_id>')
def task_status(task_id):
    task = celery.AsyncResult(task_id)
    if task.state == 'PENDING':
        response = {'state': 'PENDING', 'status': {'current': 0, 'total': 4, 'status': 'Waiting for worker...'}}
    elif task.state == 'PROGRESS':
        response = {'state': 'PROGRESS', 'status': task.info}
    elif task.state == 'SUCCESS':
         response = {'state': 'SUCCESS', 'status': task.info}
    else:
        response = {'state': task.state, 'status': str(task.info)}
    return jsonify(response)

@app.route('/generated/<name>')
def download_file(name):
    """Serves the generated audio or text file for download."""
    return send_from_directory(app.config["GENERATED_FOLDER"], name)
