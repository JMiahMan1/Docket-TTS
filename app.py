import os
import subprocess
import uuid
import re
import json
from pathlib import Path
from datetime import datetime
from flask import (
    Flask, request, render_template, send_from_directory,
    flash, redirect, url_for, jsonify
)
from werkzeug.utils import secure_filename
import docx
import ebooklib
from ebooklib import epub
from bs4 import BeautifulSoup
from celery import Celery, Task
import fitz
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, TIT2, TPE1, TALB, COMM, APIC
from PIL import Image, ImageDraw, ImageFont
import io
import redis
import shutil
import base64
import requests

from tts_service import TTSService, normalize_text

UPLOAD_FOLDER = '/app/uploads'
GENERATED_FOLDER = '/app/generated'
VOICES_FOLDER = '/app/voices'
ALLOWED_EXTENSIONS = {'txt', 'pdf', 'docx', 'epub'}

app = Flask(__name__)
app.config.from_mapping(
    UPLOAD_FOLDER=UPLOAD_FOLDER,
    GENERATED_FOLDER=GENERATED_FOLDER,
    SECRET_KEY='a-secure-and-random-secret-key'
)

def celery_init_app(app: Flask) -> Celery:
    class FlaskTask(Task):
        def __call__(self, *args: object, **kwargs: object) -> object:
            with app.app_context():
                return self.run(*args, **kwargs)

    celery_app = Celery(app.name, task_cls=FlaskTask)
    celery_app.config_from_object("celery_config")
    return celery_app

celery = celery_init_app(app)

try:
    redis_client = redis.from_url(celery.conf.broker_url)
except Exception as e:
    app.logger.error(f"Could not create Redis client: {e}")
    redis_client = None

if os.environ.get('RUNNING_IN_DOCKER'):
    os.makedirs(UPLOAD_FOLDER, exist_ok=True)
    os.makedirs(GENERATED_FOLDER, exist_ok=True)

def human_readable_size(size, decimal_places=2):
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size < 1024.0:
            break
        size /= 1024.0
    return f"{size:.{decimal_places}f} {unit}"

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def tag_mp3_file(filepath, metadata, image_data=None):
    try:
        audio = MP3(filepath)
        
        if audio.tags is None:
            audio.add_tags()

        title = metadata.get('title', 'Unknown Title')
        author = metadata.get('author', 'Unknown Author')
        
        audio.tags.add(TIT2(encoding=3, text=title))
        audio.tags.add(TPE1(encoding=3, text=author))
        audio.tags.add(TALB(encoding=3, text=title))
        audio.tags.add(COMM(encoding=3, lang='eng', desc='Comment', text='Generated by Docket TTS'))

        if image_data:
            audio.tags.add(APIC(
                encoding=3,
                mime='image/png',
                type=3, 
                desc='Cover',
                data=image_data
            ))
        
        audio.save()
        app.logger.info(f"Successfully tagged {filepath}")
    except Exception as e:
        app.logger.error(f"Failed to tag {filepath}: {e}")

def generate_placeholder_cover(title, author):
    """Generates a simple placeholder cover image and returns it as bytes."""
    image_size = (600, 600)
    background_color = "#1a1a1a"
    text_color = "#FFFFFF"
    
    img = Image.new('RGB', image_size, color=background_color)
    draw = ImageDraw.Draw(img)

    try:
        title_font = ImageFont.truetype("arial.ttf", size=45)
        author_font = ImageFont.truetype("arial.ttf", size=30)
    except IOError:
        title_font = ImageFont.load_default()
        author_font = ImageFont.load_default()

    # Simple text wrapping
    avg_char_width = 20
    wrap_width = image_size[0] // avg_char_width
    
    title_lines = [title[i:i+wrap_width] for i in range(0, len(title), wrap_width)]
    
    # Draw text
    y_pos = 150
    for line in title_lines:
        draw.text((50, y_pos), line, font=title_font, fill=text_color)
        y_pos += 50
    
    draw.text((50, y_pos + 30), f"by {author}", font=author_font, fill=text_color)
    
    # Save image to an in-memory buffer
    buffer = io.BytesIO()
    img.save(buffer, format='PNG')
    return buffer.getvalue()

def parse_metadata_from_text(text_content):
    parsed_meta = {}
    search_area = text_content[:4000]
    lines = [line.strip() for line in search_area.split('\n') if line.strip()]
    if not lines: return parsed_meta
    for line in lines:
        if line.lower().startswith('by '):
            author = line[3:].strip()
            if 2 < len(author) < 60:
                parsed_meta['author'] = author
                break
    potential_titles = []
    for line in lines[:15]:
        if 'author' in parsed_meta and parsed_meta['author'] in line: continue
        words = line.split()
        if 1 < len(words) < 12:
            if line.isupper():
                potential_titles.append((line, len(line) + 20))
            else:
                potential_titles.append((line, len(line)))
    if potential_titles:
        best_title = sorted(potential_titles, key=lambda x: x[1], reverse=True)[0][0]
        parsed_meta['title'] = best_title
    return parsed_meta

def extract_text_and_metadata(filepath):
    p_filepath = Path(filepath)
    extension = p_filepath.suffix.lower()
    text = ""
    metadata = {'title': p_filepath.stem.replace('_', ' ').title(), 'author': 'Unknown'}
    try:
        if extension == '.pdf':
            with fitz.open(filepath) as doc:
                doc_meta = doc.metadata
                if doc_meta:
                    metadata['title'] = doc_meta.get('title') or metadata['title']
                    metadata['author'] = doc_meta.get('author') or metadata['author']
                for page in doc:
                    text += page.get_text() + "\n"
        elif extension == '.docx':
            doc = docx.Document(filepath)
            if doc.core_properties:
                metadata['title'] = doc.core_properties.title or metadata['title']
                metadata['author'] = doc.core_properties.author or metadata['author']
            text = "\n".join([para.text for para in doc.paragraphs])
        elif extension == '.epub':
            book = epub.read_epub(filepath)
            titles = book.get_metadata('DC', 'title')
            if titles: metadata['title'] = titles[0][0]
            creators = book.get_metadata('DC', 'creator')
            if creators: metadata['author'] = creators[0][0]
            for item in book.get_items_of_type(ebooklib.ITEM_DOCUMENT):
                soup = BeautifulSoup(item.get_body_content(), 'html.parser')
                text += soup.get_text() + "\n\n"
        elif extension == '.txt':
            text = p_filepath.read_text(encoding='utf-8')
    except Exception as e:
        app.logger.error(f"Error extracting from {filepath}: {e}")
        return None, None
    if text:
        parsed_meta = parse_metadata_from_text(text)
        if metadata['title'] == p_filepath.stem.replace('_', ' ').title() and 'title' in parsed_meta:
            metadata['title'] = parsed_meta['title']
        if metadata['author'] == 'Unknown' and 'author' in parsed_meta:
            metadata['author'] = parsed_meta['author']
    if not metadata['title']: metadata['title'] = p_filepath.stem.replace('_', ' ').title()
    if not metadata['author']: metadata['author'] = 'Unknown'
    return text, metadata

def list_available_voices():
    voices = []
    voice_dir = Path(VOICES_FOLDER)
    if voice_dir.is_dir():
        for voice_file in voice_dir.glob("*.onnx"):
            voices.append({"id": voice_file.name, "name": voice_file.stem})
    return sorted(voices, key=lambda v: v['name'])

@celery.task(bind=True)
def convert_to_speech_task(self, input_filepath, original_filename, voice_name=None):
    try:
        self.update_state(state='PROGRESS', meta={'current': 1, 'total': 4, 'status': 'Extracting text...'})
        text_content, metadata = extract_text_and_metadata(input_filepath)
        if not text_content or not metadata: raise ValueError('Could not extract text.')
        if Path(original_filename).suffix == '.txt' and 'title' in metadata:
            metadata['title'] = Path(original_filename).stem.replace('_', ' ').title()
        self.update_state(state='PROGRESS', meta={'current': 2, 'total': 4, 'status': 'Synthesizing audio...'})
        unique_id = str(uuid.uuid4().hex[:8])
        base_name = re.sub(r'[^a-zA-Z0-9_-]', '_', Path(original_filename).stem)
        output_filename = f"{base_name}_{unique_id}.mp3"
        output_filepath = os.path.join(GENERATED_FOLDER, output_filename)
        tts = TTSService(voice=voice_name)
        _, normalized_text = tts.synthesize(text_content, output_filepath)
        self.update_state(state='PROGRESS', meta={'current': 3, 'total': 4, 'status': 'Tagging audio...'})
        tag_mp3_file(output_filepath, metadata)
        self.update_state(state='PROGRESS', meta={'current': 4, 'total': 4, 'status': 'Saving text file...'})
        text_filename = f"{base_name}_{unique_id}.txt"
        text_filepath = os.path.join(GENERATED_FOLDER, text_filename)
        Path(text_filepath).write_text(normalized_text, encoding="utf-8")
        if os.path.exists(input_filepath):
            os.remove(input_filepath)
        return {'status': 'Success', 'filename': output_filename, 'textfile': text_filename}
    except Exception as e:
        app.logger.error(f"TTS Conversion failed in task {self.request.id}: {e}")
        if os.path.exists(input_filepath):
            os.remove(input_filepath)
        self.update_state(state='FAILURE', meta={'exc_type': type(e).__name__, 'exc_message': str(e)})
        raise e

def _create_audiobook_logic(file_list, audiobook_title, audiobook_author, cover_url, build_dir, task_self=None):
    def update_state(state, meta):
        if task_self:
            task_self.update_state(state=state, meta=meta)

    unique_file_list = sorted(list(set(file_list)))
    
    update_state(state='PROGRESS', meta={'current': 1, 'total': 5, 'status': 'Gathering chapters and text...'})
    safe_mp3_paths = [Path(GENERATED_FOLDER) / secure_filename(fname) for fname in unique_file_list]
    
    update_state(state='PROGRESS', meta={'current': 2, 'total': 5, 'status': 'Gathering cover art...'})
    cover_image_data = None
    if cover_url:
        try:
            response = requests.get(cover_url, stream=True)
            response.raise_for_status()
            cover_image_data = response.content
            app.logger.info("Successfully downloaded cover art from URL.")
        except requests.RequestException as e:
            app.logger.error(f"Failed to download cover art: {e}. Generating placeholder.")
            cover_image_data = generate_placeholder_cover(audiobook_title, audiobook_author)
    else:
        app.logger.info("No cover URL provided. Generating placeholder cover.")
        cover_image_data = generate_placeholder_cover(audiobook_title, audiobook_author)

    update_state(state='PROGRESS', meta={'current': 3, 'total': 5, 'status': 'Analyzing chapters...'})
    concat_list_content = ""
    for i, path in enumerate(safe_mp3_paths):
        concat_list_content += f"file '{path.resolve()}'\n"
    concat_list_path = build_dir / "concat_list.txt"
    concat_list_path.write_text(concat_list_content)
    
    update_state(state='PROGRESS', meta={'current': 4, 'total': 5, 'status': 'Merging and encoding audio...'})
    temp_audio_path = build_dir / "temp_audio.mp3"
    concat_command = ['ffmpeg', '-f', 'concat', '-safe', '0', '-i', str(concat_list_path), '-c', 'copy', str(temp_audio_path)]
    subprocess.run(concat_command, check=True, capture_output=True)

    update_state(state='PROGRESS', meta={'current': 5, 'total': 5, 'status': 'Tagging audiobook...'})
    tag_mp3_file(temp_audio_path, {'title': audiobook_title, 'author': audiobook_author}, cover_image_data)

    timestamp = build_dir.name.replace('audiobook_build_', '')
    output_filename = f"{secure_filename(audiobook_title)}_{timestamp}.mp3"
    output_filepath = Path(GENERATED_FOLDER) / output_filename
    shutil.move(temp_audio_path, output_filepath)
        
    return {'status': 'Success', 'filename': output_filename}

@celery.task(bind=True)
def create_audiobook_task(self, file_list, audiobook_title, audiobook_author, cover_url=None):
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    build_dir = Path(GENERATED_FOLDER) / f"audiobook_build_{timestamp}"
    os.makedirs(build_dir, exist_ok=True)
    try:
        # Reverted logic for audiobook creation to use MP3 format
        unique_file_list = sorted(list(set(file_list)))
        self.update_state(state='PROGRESS', meta={'current': 1, 'total': 4, 'status': 'Downloading cover art...'})
        cover_image_data = None
        if cover_url:
            try:
                response = requests.get(cover_url)
                response.raise_for_status()
                cover_image_data = response.content
            except requests.RequestException as e:
                app.logger.error(f"Failed to download cover: {e}. Generating placeholder.")
                cover_image_data = generate_placeholder_cover(audiobook_title, audiobook_author)
        else:
            cover_image_data = generate_placeholder_cover(audiobook_title, audiobook_author)
            
        self.update_state(state='PROGRESS', meta={'current': 2, 'total': 4, 'status': 'Creating chapter list...'})
        concat_list_content = ""
        for path_str in unique_file_list:
            path = Path(GENERATED_FOLDER) / secure_filename(path_str)
            if path.exists():
                concat_list_content += f"file '{path.resolve()}'\n"
        
        concat_list_path = build_dir / "concat_list.txt"
        concat_list_path.write_text(concat_list_content)
        
        self.update_state(state='PROGRESS', meta={'current': 3, 'total': 4, 'status': 'Merging audio files...'})
        temp_audio_path = build_dir / "temp_merged_audio.mp3"
        ffmpeg_command = ['ffmpeg', '-f', 'concat', '-safe', '0', '-i', str(concat_list_path), '-c', 'copy', str(temp_audio_path)]
        subprocess.run(ffmpeg_command, check=True, capture_output=True)

        self.update_state(state='PROGRESS', meta={'current': 4, 'total': 4, 'status': 'Tagging final audiobook...'})
        tag_mp3_file(temp_audio_path, {'title': audiobook_title, 'author': audiobook_author}, cover_image_data)
        
        output_filename = f"{secure_filename(audiobook_title)}_{timestamp}.mp3"
        output_filepath = Path(GENERATED_FOLDER) / output_filename
        shutil.move(temp_audio_path, output_filepath)

        return {'status': 'Success', 'filename': output_filename}

    except Exception as e:
        app.logger.error(f"Audiobook creation failed: {e}")
        if isinstance(e, subprocess.CalledProcessError):
            app.logger.error(f"FFMPEG stderr: {e.stderr.decode()}")
        self.update_state(state='FAILURE', meta={'exc_type': type(e).__name__, 'exc_message': str(e)})
        raise e
    finally:
        if build_dir.exists():
            shutil.rmtree(build_dir)


@app.route('/', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        voice_name = request.form.get("voice")
        text_input = request.form.get('text_input')
        if text_input and text_input.strip():
            title = request.form.get('text_title')
            if not title or not title.strip():
                flash('Title is required for pasted text.', 'error')
                return redirect(request.url)
            original_filename = f"{secure_filename(title.strip())}.txt"
            unique_internal_filename = f"{uuid.uuid4().hex}.txt"
            input_filepath = os.path.join(app.config['UPLOAD_FOLDER'], unique_internal_filename)
            Path(input_filepath).write_text(text_input, encoding='utf-8')
            task = convert_to_speech_task.delay(input_filepath, original_filename, voice_name)
            return render_template('result.html', task_id=task.id)
        
        file = request.files.get('file')
        if not file or file.filename == '':
            flash('No file selected.', 'error')
            return redirect(request.url)
        if file and allowed_file(file.filename):
            original_filename = secure_filename(file.filename)
            unique_internal_filename = f"{uuid.uuid4().hex}{Path(original_filename).suffix}"
            input_filepath = os.path.join(app.config['UPLOAD_FOLDER'], unique_internal_filename)
            file.save(input_filepath)
            task = convert_to_speech_task.delay(input_filepath, original_filename, voice_name)
            return render_template('result.html', task_id=task.id)
        else:
            flash(f'Invalid file type. Allowed types are: {", ".join(ALLOWED_EXTENSIONS)}.', 'error')
            return redirect(request.url)
    voices = list_available_voices()
    return render_template('index.html', voices=voices)

@app.route('/files')
def list_files():
    file_map = {}
    all_files = sorted(Path(GENERATED_FOLDER).iterdir(), key=os.path.getmtime, reverse=True)
    for entry in all_files:
        if not entry.is_file() or entry.name.startswith('sample_'):
            continue
        match = re.match(r'^(.*?)_([a-f0-9]{8})$', entry.stem)
        if match:
            base_name, unique_id = match.groups()
            key = f"{base_name}_{unique_id}"
        else:
            key = entry.stem
        if key not in file_map:
            file_map[key] = {'base_name': f"{base_name}_{unique_id}" if match else entry.stem}
        if entry.suffix in ['.mp3', '.m4b']:
            file_map[key]['audio_name'] = entry.name
            file_map[key]['size'] = human_readable_size(entry.stat().st_size)
            file_map[key]['date'] = datetime.fromtimestamp(entry.stat().st_mtime).strftime('%Y-%m-%d %H:%M')
        elif entry.suffix == '.txt':
            file_map[key]['txt_name'] = entry.name
    audio_files = [data for data in file_map.values() if 'audio_name' in data]
    return render_template('files.html', audio_files=audio_files)

@app.route('/get-book-metadata', methods=['POST'])
def get_book_metadata():
    filenames = request.json.get('filenames', [])
    if not filenames:
        return jsonify({'error': 'No filenames provided'}), 400
    match = re.match(r'^(.*?)_([a-f0-9]{8})$', Path(filenames[0]).stem)
    first_file_path_stem = match.group(1) if match else Path(filenames[0]).stem
    title_from_name = first_file_path_stem.replace('_', ' ').replace('-', ' ').title()
    metadata = {'title': title_from_name, 'author': 'Unknown'}
    txt_filename = next((f.replace('.mp3', '.txt') for f in filenames if f.endswith('.mp3')), None)
    if txt_filename and (txt_path := Path(GENERATED_FOLDER) / txt_filename).exists():
        text = txt_path.read_text(encoding='utf-8')
        parsed_meta = parse_metadata_from_text(text)
        metadata['author'] = parsed_meta.get('author', metadata['author'])
    title = metadata.get('title', '')
    author = metadata.get('author', '')
    cover_url = ''
    if title:
        try:
            query = f"intitle:{title}"
            if author and author != 'Unknown':
                query += f"+inauthor:{author}"
            response = requests.get(f"https://www.googleapis.com/books/v1/volumes?q={query}&maxResults=1")
            response.raise_for_status()
            data = response.json()
            if data.get('totalItems', 0) > 0:
                book_info = data['items'][0]['volumeInfo']
                title = book_info.get('title', title)
                author = ", ".join(book_info.get('authors', [author]))
                cover_url = book_info.get('imageLinks', {}).get('thumbnail', '')
        except requests.RequestException as e:
            app.logger.error(f"Google Books API request failed: {e}")
    return jsonify({'title': title, 'author': author, 'cover_url': cover_url})

@app.route('/create-audiobook', methods=['POST'])
def create_audiobook():
    files_to_merge = request.form.getlist('files_to_merge')
    audiobook_title = request.form.get('title', 'Untitled Audiobook')
    audiobook_author = request.form.get('author', 'Unknown Author')
    cover_url = request.form.get('cover_url', '')
    if not files_to_merge:
        flash("Please select at least one MP3 file.", "warning")
        return redirect(url_for('list_files'))
    task = create_audiobook_task.delay(files_to_merge, audiobook_title, audiobook_author, cover_url)
    return render_template('result.html', task_id=task.id)

@app.route('/jobs')
def jobs_page():
    running_jobs, queued_jobs = [], []
    unassigned_job_count = 0
    try:
        inspector = celery.control.inspect()
        active_tasks = inspector.active() or {}
        for worker_name, tasks in active_tasks.items():
            for task in tasks:
                original_filename = "N/A"
                if (task_args := task.get('args')) and isinstance(task_args, (list, tuple)) and len(task_args) > 1:
                    original_filename = Path(task_args[1]).name
                running_jobs.append({'id': task['id'], 'name': original_filename, 'worker': worker_name})
        
        reserved_tasks = inspector.reserved() or {}
        for worker_name, tasks in reserved_tasks.items():
            for task in tasks:
                original_filename = "N/A"
                if (task_args := task.get('args')) and isinstance(task_args, (list, tuple)) and len(task_args) > 1:
                    original_filename = Path(task_args[1]).name
                queued_jobs.append({'id': task['id'], 'name': original_filename, 'status': 'Reserved'})
        
        if redis_client:
            try:
                unassigned_job_count = redis_client.llen('celery')
            except Exception as e:
                app.logger.error(f"Could not get queue length from Redis: {e}")

    except Exception as e:
        app.logger.error(f"Could not inspect Celery/Redis: {e}")
        flash("Could not connect to the Celery worker or Redis.", "error")
        
    return render_template('jobs.html', running_jobs=running_jobs, waiting_jobs=queued_jobs, unassigned_job_count=unassigned_job_count)

@app.route('/cancel-job/<task_id>', methods=['POST'])
def cancel_job(task_id):
    if not task_id:
        flash('Invalid task ID.', 'error')
        return redirect(url_for('jobs_page'))
    celery.control.revoke(task_id, terminate=True, signal='SIGKILL')
    flash(f'Cancellation request sent for job {task_id}.', 'success')
    return redirect(url_for('jobs_page'))

@app.route('/delete-bulk', methods=['POST'])
def delete_bulk():
    basenames_to_delete = set(request.form.getlist('files_to_delete'))
    if not basenames_to_delete:
        flash("No files selected for deletion.", "warning")
        return redirect(url_for('list_files'))
    deleted_count = 0
    for base_name in basenames_to_delete:
        safe_base_name = secure_filename(base_name)
        for f in Path(GENERATED_FOLDER).glob(f"{safe_base_name}.*"):
            try:
                f.unlink()
                deleted_count +=1
            except OSError as e:
                app.logger.error(f"Error deleting file {f}: {e}")
    flash(f"Successfully deleted {deleted_count} file(s).", "success")
    return redirect(url_for('list_files'))

@app.route('/speak_sample/<voice_name>')
def speak_sample(voice_name):
    sample_text = "This is a sample of my voice."
    safe_voice_name = secure_filename(Path(voice_name).stem)
    filename = f"sample_{safe_voice_name}.mp3"
    filepath = os.path.join(GENERATED_FOLDER, filename)
    if not os.path.exists(filepath):
        try:
            tts = TTSService(voice=voice_name)
            tts.synthesize(sample_text, filepath)
        except Exception as e:
            return f"Error generating sample: {e}", 500
    return send_from_directory(app.config["GENERATED_FOLDER"], filename)

@app.route('/status/<task_id>')
def task_status(task_id):
    task = celery.AsyncResult(task_id)
    if task.state == 'PENDING':
        response = {'state': 'PENDING', 'status': {'current': 0, 'total': 5, 'status': 'Waiting...'}}
    elif task.state == 'PROGRESS':
        response = {'state': 'PROGRESS', 'status': task.info}
    elif task.state == 'SUCCESS':
        response = {'state': 'SUCCESS', 'status': task.info}
    else:
        response = {'state': task.state, 'status': str(task.info)}
    return jsonify(response)

@app.route('/generated/<name>')
def download_file(name):
    return send_from_directory(app.config["GENERATED_FOLDER"], name)
