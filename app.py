import os
import subprocess
import uuid
import re
import json
from pathlib import Path
from datetime import datetime
from flask import (
    Flask, request, render_template, send_from_directory,
    flash, redirect, url_for, jsonify
)
from werkzeug.utils import secure_filename
import docx
import ebooklib
from ebooklib import epub
from bs4 import BeautifulSoup
from celery import Celery, Task
import fitz  # PyMuPDF
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, TIT2, TPE1, TALB, COMM
import redis

from tts_service import TTSService

# --- Configuration ---
UPLOAD_FOLDER = '/app/uploads'
GENERATED_FOLDER = '/app/generated'
VOICES_FOLDER = '/app/voices'
ALLOWED_EXTENSIONS = {'txt', 'pdf', 'docx', 'epub'}

# --- Flask App Initialization ---
app = Flask(__name__)
app.config.from_mapping(
    UPLOAD_FOLDER=UPLOAD_FOLDER,
    GENERATED_FOLDER=GENERATED_FOLDER,
    SECRET_KEY='a-secure-and-random-secret-key'
)

# --- Celery Configuration ---
def celery_init_app(app: Flask) -> Celery:
    class FlaskTask(Task):
        def __call__(self, *args: object, **kwargs: object) -> object:
            with app.app_context():
                return self.run(*args, **kwargs)

    celery_app = Celery(app.name, task_cls=FlaskTask)
    celery_app.config_from_object("celery_config")
    return celery_app

celery = celery_init_app(app)

try:
    redis_client = redis.from_url(celery.conf.broker_url)
except Exception as e:
    app.logger.error(f"Could not create Redis client: {e}")
    redis_client = None


# --- Ensure Directories Exist ---
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(GENERATED_FOLDER, exist_ok=True)


# --- Helper Functions ---
def allowed_file(filename):
    """Check if the uploaded file has an allowed extension."""
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def tag_mp3_file(filepath, metadata):
    """Adds ID3 metadata tags to the generated MP3 file correctly."""
    try:
        audio = MP3(filepath)

        if audio.tags is None:
            audio.add_tags()
        
        title = metadata.get('title', 'Unknown Title')
        author = metadata.get('author', 'Unknown Author')
        
        safe_title = (title[:100] + '..') if len(title) > 100 else title
        safe_author = (author[:100] + '..') if len(author) > 100 else author
        
        audio.tags.add(TIT2(encoding=3, text=safe_title))
        audio.tags.add(TPE1(encoding=3, text=safe_author))
        audio.tags.add(TALB(encoding=3, text=safe_title)) # Use title for Album as well
        audio.tags.add(COMM(encoding=3, lang='eng', desc='Comment', text='Generated by Docket TTS'))
        
        audio.save()
        app.logger.info(f"Successfully tagged {filepath}")
    except Exception as e:
        app.logger.error(f"Failed to tag {filepath}: {e}")

def parse_metadata_from_text(text_content):
    """Scans the beginning of text to find Title and Author as a fallback."""
    parsed_meta = {}
    search_area = text_content[:4000]
    lines = [line.strip() for line in search_area.split('\n') if line.strip()]

    if not lines:
        return parsed_meta

    for line in lines:
        if line.lower().startswith('by '):
            author = line[3:].strip()
            if 2 < len(author) < 60:
                parsed_meta['author'] = author
                break

    potential_titles = []
    for line in lines[:15]:
        if 'author' in parsed_meta and parsed_meta['author'] in line:
            continue
        
        words = line.split()
        if 1 < len(words) < 12:
            if line.isupper():
                potential_titles.append((line, len(line) + 20))
            else:
                potential_titles.append((line, len(line)))

    if potential_titles:
        best_title = sorted(potential_titles, key=lambda x: x[1], reverse=True)[0][0]
        parsed_meta['title'] = best_title

    return parsed_meta

def extract_text_and_metadata(filepath):
    """
    Extracts text and metadata from files, using text parsing as a fallback.
    """
    p_filepath = Path(filepath)
    extension = p_filepath.suffix.lower()
    text = ""
    metadata = {'title': p_filepath.stem.replace('_', ' ').title(), 'author': 'Unknown'}

    try:
        if extension == '.pdf':
            cleaned_filepath = f"{filepath}.cleaned.pdf"
            gs_command = ['gs', '-sDEVICE=pdfwrite', '-dCompatibilityLevel=1.7', '-dNOPAUSE', '-dBATCH', f'-sOutputFile={cleaned_filepath}', filepath]
            subprocess.run(gs_command, check=True, capture_output=True)
            
            with fitz.open(cleaned_filepath) as doc:
                doc_meta = doc.metadata
                if doc_meta:
                    metadata['title'] = doc_meta.get('title') or metadata['title']
                    metadata['author'] = doc_meta.get('author') or metadata['author']
                for page in doc:
                    text += page.get_text() + "\n"
            os.remove(cleaned_filepath)

        elif extension == '.docx':
            doc = docx.Document(filepath)
            if doc.core_properties:
                metadata['title'] = doc.core_properties.title or metadata['title']
                metadata['author'] = doc.core_properties.author or metadata['author']
            text = "\n".join([para.text for para in doc.paragraphs])
            
        elif extension == '.epub':
            book = epub.read_epub(filepath)
            titles = book.get_metadata('DC', 'title')
            if titles: metadata['title'] = titles[0][0]
            creators = book.get_metadata('DC', 'creator')
            if creators: metadata['author'] = creators[0][0]
                
            for item in book.get_items_of_type(ebooklib.ITEM_DOCUMENT):
                soup = BeautifulSoup(item.get_body_content(), 'html.parser')
                text += soup.get_text() + "\n\n"
        
        elif extension == '.txt':
            text = p_filepath.read_text(encoding='utf-8')

    except Exception as e:
        app.logger.error(f"Error extracting from {filepath}: {e}")
        if 'cleaned_filepath' in locals() and os.path.exists(cleaned_filepath):
            os.remove(cleaned_filepath)
        return None, None
        
    if text:
        parsed_meta = parse_metadata_from_text(text)
        if metadata['title'] == p_filepath.stem.replace('_', ' ').title() and 'title' in parsed_meta:
            metadata['title'] = parsed_meta['title']
        if metadata['author'] == 'Unknown' and 'author' in parsed_meta:
            metadata['author'] = parsed_meta['author']
            
    if not metadata['title']: metadata['title'] = p_filepath.stem.replace('_', ' ').title()
    if not metadata['author']: metadata['author'] = 'Unknown'

    return text, metadata

def list_available_voices():
    voices = []
    voice_dir = Path(VOICES_FOLDER)
    if voice_dir.is_dir():
        for voice_file in voice_dir.glob("*.onnx"):
            voices.append({"id": voice_file.name, "name": voice_file.stem})
    return sorted(voices, key=lambda v: v['name'])

@celery.task(bind=True)
def convert_to_speech_task(self, input_filepath, original_filename, voice_name=None):
    """Background task that extracts text/metadata, synthesizes, and tags the MP3."""
    try:
        self.update_state(state='PROGRESS', meta={'current': 1, 'total': 4, 'status': 'Extracting text and metadata...'})
        text_content, metadata = extract_text_and_metadata(input_filepath)
        if not text_content or not metadata:
            raise ValueError('Could not extract text or metadata from the file.')

        self.update_state(state='PROGRESS', meta={'current': 2, 'total': 4, 'status': 'Synthesizing audio...'})
        unique_id = str(uuid.uuid4().hex[:8])
        base_name = Path(original_filename).stem
        output_filename = f"{base_name}_{unique_id}.mp3"
        output_filepath = os.path.join(GENERATED_FOLDER, output_filename)
        
        tts = TTSService(voice=voice_name)
        _, normalized_text = tts.synthesize(text_content, output_filepath)

        self.update_state(state='PROGRESS', meta={'current': 3, 'total': 4, 'status': 'Tagging audio file...'})
        tag_mp3_file(output_filepath, metadata)

        self.update_state(state='PROGRESS', meta={'current': 4, 'total': 4, 'status': 'Saving text file...'})
        text_filename = f"{base_name}_{unique_id}.txt"
        text_filepath = os.path.join(GENERATED_FOLDER, text_filename)
        Path(text_filepath).write_text(normalized_text, encoding="utf-8")

        return {'status': 'Success', 'filename': output_filename, 'textfile': text_filename}
    except Exception as e:
        app.logger.error(f"TTS Conversion failed in task {self.request.id}: {e}")
        self.update_state(state='FAILURE', meta={'exc_type': type(e).__name__, 'exc_message': str(e)})
        raise e

@app.route('/', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        if 'file' not in request.files:
            flash('No file part in the request.', 'error')
            return redirect(request.url)
        file = request.files['file']
        if file.filename == '' or not allowed_file(file.filename):
            flash('Invalid file. Please select a TXT, DOCX, EPUB, or PDF file.', 'error')
            return redirect(request.url)

        original_filename = secure_filename(file.filename)
        input_filepath = os.path.join(app.config['UPLOAD_FOLDER'], original_filename)
        file.save(input_filepath)

        voice_name = request.form.get("voice")
        task = convert_to_speech_task.delay(input_filepath, original_filename, voice_name)
        return render_template('result.html', task_id=task.id)

    voices = list_available_voices()
    return render_template('index.html', voices=voices)

@app.route('/files')
def list_files():
    paired_files = {}
    all_files = sorted(Path(GENERATED_FOLDER).iterdir(), key=os.path.getmtime, reverse=True)

    for entry in all_files:
        if entry.is_file() and not entry.name.startswith('sample_'):
            base_name = entry.stem
            if base_name not in paired_files:
                paired_files[base_name] = {
                    'base_name': base_name,
                    'date': datetime.fromtimestamp(entry.stat().st_mtime).strftime('%Y-%m-%d %H:%M')
                }
            if entry.suffix == '.mp3':
                paired_files[base_name]['mp3_name'] = entry.name
            elif entry.suffix == '.txt':
                paired_files[base_name]['txt_name'] = entry.name
    
    audio_files = [data for data in paired_files.values() if 'mp3_name' in data]
    return render_template('files.html', audio_files=audio_files)

@app.route('/merge', methods=['POST'])
def merge_mp3s():
    files_to_merge = request.form.getlist('files_to_merge')
    if len(files_to_merge) < 2:
        flash("Please select at least two MP3 files to merge.", "warning")
        return redirect(url_for('list_files'))

    safe_paths = []
    for fname in files_to_merge:
        safe_fname = secure_filename(fname)
        path = Path(GENERATED_FOLDER) / safe_fname
        if path.exists() and path.suffix == '.mp3':
            safe_paths.append(path)
    
    if len(safe_paths) < 2:
        flash("Invalid or missing files selected for merging.", "error")
        return redirect(url_for('list_files'))

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_filename = f"merged_audio_{timestamp}.mp3"
    output_filepath = Path(GENERATED_FOLDER) / output_filename
    mergelist_path = Path(GENERATED_FOLDER) / f"mergelist_{timestamp}.txt"

    try:
        safe_paths.sort()
        with open(mergelist_path, 'w') as f:
            for path in safe_paths:
                f.write(f"file '{path.name}'\n")

        ffmpeg_command = [
            'ffmpeg', '-f', 'concat', '-safe', '0', '-i', str(mergelist_path),
            '-c', 'copy', str(output_filepath)
        ]
        subprocess.run(ffmpeg_command, check=True, cwd=GENERATED_FOLDER, capture_output=True)
        
        flash(f"Successfully merged {len(safe_paths)} files into {output_filename}.", "success")

    except subprocess.CalledProcessError as e:
        app.logger.error(f"FFMPEG merge failed: {e.stderr.decode()}")
        flash("An error occurred during the merge process.", "error")
    except Exception as e:
        app.logger.error(f"Merge process failed: {e}")
        flash("An unexpected error occurred.", "error")
    finally:
        if mergelist_path.exists():
            mergelist_path.unlink()

    return redirect(url_for('list_files'))

@app.route('/jobs')
def jobs_page():
    running_jobs = []
    queued_jobs = []

    try:
        # 1. Get running jobs from Celery worker inspection
        inspector = celery.control.inspect()
        active_tasks = inspector.active()
        if active_tasks:
            for worker_name, tasks in active_tasks.items():
                for task in tasks:
                    original_filename = "N/A"
                    task_args = task.get('args')
                    if task_args and isinstance(task_args, (list, tuple)) and len(task_args) > 1:
                        original_filename = Path(task_args[1]).name
                    
                    running_jobs.append({
                        'id': task['id'],
                        'name': original_filename,
                        'worker': worker_name
                    })

        # 2. Get queued jobs by inspecting the Redis queue directly
        if redis_client:
            # Celery's default queue name is 'celery'
            queued_task_messages = redis_client.lrange('celery', 0, -1)
            for message in queued_task_messages:
                try:
                    # Decode message and load the JSON body
                    j = json.loads(message.decode('utf-8'))
                    # The arguments are base64 encoded, but we can decode the properties to get the ID
                    task_id = j['headers']['id']
                    # The arguments are inside a nested tuple
                    task_args = j['body'][0]
                    original_filename = Path(task_args[1]).name if len(task_args) > 1 else "N/A"
                    
                    queued_jobs.append({
                        'id': task_id,
                        'name': original_filename
                    })
                except (json.JSONDecodeError, KeyError, IndexError) as e:
                    app.logger.error(f"Could not parse queued task message: {e}")
        
    except Exception as e:
        app.logger.error(f"Could not inspect Celery workers or Redis queue: {e}")
        flash("Could not connect to the Celery worker or Redis. One may be offline or starting up.", "error")
        
    return render_template('jobs.html', running_jobs=running_jobs, queued_jobs=queued_jobs)


@app.route('/delete-bulk', methods=['POST'])
def delete_bulk():
    basenames_to_delete = set(request.form.getlist('files_to_delete'))
    if not basenames_to_delete:
        flash("No files selected for deletion.", "warning")
        return redirect(url_for('list_files'))

    deleted_count = 0
    for base_name in basenames_to_delete:
        safe_base_name = secure_filename(base_name)
        mp3_path = Path(GENERATED_FOLDER) / f"{safe_base_name}.mp3"
        txt_path = Path(GENERATED_FOLDER) / f"{safe_base_name}.txt"
        
        if mp3_path.exists() and mp3_path.is_file():
            mp3_path.unlink()
            deleted_count += 1
        if txt_path.exists() and txt_path.is_file():
            txt_path.unlink()
            
    flash(f"Successfully deleted {deleted_count} file(s) and their pairs.", "success")
    return redirect(url_for('list_files'))

@app.route('/speak_sample/<voice_name>')
def speak_sample(voice_name):
    sample_text = "This is a sample of my voice."
    filename = f"sample_{Path(voice_name).stem}.mp3"
    filepath = os.path.join(GENERATED_FOLDER, filename)
    if not os.path.exists(filepath):
        try:
            tts = TTSService(voice=voice_name)
            tts.synthesize(sample_text, filepath)
        except Exception as e:
            return f"Error generating sample: {e}", 500
    return send_from_directory(app.config["GENERATED_FOLDER"], filename)

@app.route('/status/<task_id>')
def task_status(task_id):
    task = celery.AsyncResult(task_id)
    if task.state == 'PENDING':
        response = {'state': 'PENDING', 'status': {'current': 0, 'total': 4, 'status': 'Waiting for worker...'}}
    elif task.state == 'PROGRESS':
        response = {'state': 'PROGRESS', 'status': task.info}
    elif task.state == 'SUCCESS':
         response = {'state': 'SUCCESS', 'status': task.info}
    else:
        response = {'state': task.state, 'status': str(task.info)}
    return jsonify(response)

@app.route('/generated/<name>')
def download_file(name):
    """Serves the generated audio or text file for download."""
    return send_from_directory(app.config["GENERATED_FOLDER"], name)
