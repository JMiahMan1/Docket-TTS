import os
import subprocess
import uuid
import re
import json
from pathlib import Path
from datetime import datetime
from flask import (
    Flask, request, render_template, send_from_directory,
    flash, redirect, url_for, jsonify
)
from werkzeug.utils import secure_filename
import docx
import ebooklib
from ebooklib import epub
from bs4 import BeautifulSoup
from celery import Celery, Task
import fitz
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, TIT2, TPE1, TALB, COMM
import redis
import shutil

from tts_service import TTSService

# --- Configuration ---
UPLOAD_FOLDER = '/app/uploads'
GENERATED_FOLDER = '/app/generated'
VOICES_FOLDER = '/app/voices'
ALLOWED_EXTENSIONS = {'txt', 'pdf', 'docx', 'epub'}

# --- Flask App Initialization ---
app = Flask(__name__)
app.config.from_mapping(
    UPLOAD_FOLDER=UPLOAD_FOLDER,
    GENERATED_FOLDER=GENERATED_FOLDER,
    SECRET_KEY='a-secure-and-random-secret-key'
)

# --- Celery Configuration ---
def celery_init_app(app: Flask) -> Celery:
    class FlaskTask(Task):
        def __call__(self, *args: object, **kwargs: object) -> object:
            with app.app_context():
                return self.run(*args, **kwargs)

    celery_app = Celery(app.name, task_cls=FlaskTask)
    celery_app.config_from_object("celery_config")
    return celery_app

celery = celery_init_app(app)

# --- Redis client for inspecting the queue ---
try:
    redis_client = redis.from_url(celery.conf.broker_url)
except Exception as e:
    app.logger.error(f"Could not create Redis client: {e}")
    redis_client = None

# --- Ensure Directories Exist ---
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(GENERATED_FOLDER, exist_ok=True)


# --- Helper Functions ---
def allowed_file(filename):
    """Check if the uploaded file has an allowed extension."""
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def tag_mp3_file(filepath, metadata):
    """Adds ID3 metadata tags to the generated MP3 file correctly."""
    try:
        audio = MP3(filepath)
        if audio.tags is None: audio.add_tags()
        title = metadata.get('title', 'Unknown Title')
        author = metadata.get('author', 'Unknown Author')
        safe_title = (title[:100] + '..') if len(title) > 100 else title
        safe_author = (author[:100] + '..') if len(author) > 100 else author
        audio.tags.add(TIT2(encoding=3, text=safe_title))
        audio.tags.add(TPE1(encoding=3, text=safe_author))
        audio.tags.add(TALB(encoding=3, text=safe_title))
        audio.tags.add(COMM(encoding=3, lang='eng', desc='Comment', text='Generated by Docket TTS'))
        audio.save()
        app.logger.info(f"Successfully tagged {filepath}")
    except Exception as e:
        app.logger.error(f"Failed to tag {filepath}: {e}")

def parse_metadata_from_text(text_content):
    """Scans the beginning of text to find Title and Author as a fallback."""
    parsed_meta = {}
    search_area = text_content[:4000]
    lines = [line.strip() for line in search_area.split('\n') if line.strip()]
    if not lines: return parsed_meta
    for line in lines:
        if line.lower().startswith('by '):
            author = line[3:].strip()
            if 2 < len(author) < 60:
                parsed_meta['author'] = author
                break
    potential_titles = []
    for line in lines[:15]:
        if 'author' in parsed_meta and parsed_meta['author'] in line: continue
        words = line.split()
        if 1 < len(words) < 12:
            if line.isupper():
                potential_titles.append((line, len(line) + 20))
            else:
                potential_titles.append((line, len(line)))
    if potential_titles:
        best_title = sorted(potential_titles, key=lambda x: x[1], reverse=True)[0][0]
        parsed_meta['title'] = best_title
    return parsed_meta

def extract_text_and_metadata(filepath):
    """
    Extracts text and metadata from files, using text parsing as a fallback.
    """
    p_filepath = Path(filepath)
    extension = p_filepath.suffix.lower()
    text = ""
    metadata = {'title': p_filepath.stem.replace('_', ' ').title(), 'author': 'Unknown'}
    try:
        if extension == '.pdf':
            with fitz.open(filepath) as doc:
                doc_meta = doc.metadata
                if doc_meta:
                    metadata['title'] = doc_meta.get('title') or metadata['title']
                    metadata['author'] = doc_meta.get('author') or metadata['author']
                for page in doc:
                    text += page.get_text() + "\n"
        elif extension == '.docx':
            doc = docx.Document(filepath)
            if doc.core_properties:
                metadata['title'] = doc.core_properties.title or metadata['title']
                metadata['author'] = doc.core_properties.author or metadata['author']
            text = "\n".join([para.text for para in doc.paragraphs])
        elif extension == '.epub':
            book = epub.read_epub(filepath)
            titles = book.get_metadata('DC', 'title')
            if titles: metadata['title'] = titles[0][0]
            creators = book.get_metadata('DC', 'creator')
            if creators: metadata['author'] = creators[0][0]
            for item in book.get_items_of_type(ebooklib.ITEM_DOCUMENT):
                soup = BeautifulSoup(item.get_body_content(), 'html.parser')
                text += soup.get_text() + "\n\n"
        elif extension == '.txt':
            text = p_filepath.read_text(encoding='utf-8')
    except Exception as e:
        app.logger.error(f"Error extracting from {filepath}: {e}")
        return None, None
    if text:
        parsed_meta = parse_metadata_from_text(text)
        if metadata['title'] == p_filepath.stem.replace('_', ' ').title() and 'title' in parsed_meta:
            metadata['title'] = parsed_meta['title']
        if metadata['author'] == 'Unknown' and 'author' in parsed_meta:
            metadata['author'] = parsed_meta['author']
    if not metadata['title']: metadata['title'] = p_filepath.stem.replace('_', ' ').title()
    if not metadata['author']: metadata['author'] = 'Unknown'
    return text, metadata

def list_available_voices():
    voices = []
    voice_dir = Path(VOICES_FOLDER)
    if voice_dir.is_dir():
        for voice_file in voice_dir.glob("*.onnx"):
            voices.append({"id": voice_file.name, "name": voice_file.stem})
    return sorted(voices, key=lambda v: v['name'])

@celery.task(bind=True)
def convert_to_speech_task(self, input_filepath, original_filename, voice_name=None):
    try:
        self.update_state(state='PROGRESS', meta={'current': 1, 'total': 4, 'status': 'Extracting text...'})
        text_content, metadata = extract_text_and_metadata(input_filepath)
        if not text_content or not metadata: raise ValueError('Could not extract text.')
        self.update_state(state='PROGRESS', meta={'current': 2, 'total': 4, 'status': 'Synthesizing audio...'})
        unique_id = str(uuid.uuid4().hex[:8])
        base_name = Path(original_filename).stem
        output_filename = f"{base_name}_{unique_id}.mp3"
        output_filepath = os.path.join(GENERATED_FOLDER, output_filename)
        tts = TTSService(voice=voice_name)
        _, normalized_text = tts.synthesize(text_content, output_filepath)
        self.update_state(state='PROGRESS', meta={'current': 3, 'total': 4, 'status': 'Tagging audio...'})
        tag_mp3_file(output_filepath, metadata)
        self.update_state(state='PROGRESS', meta={'current': 4, 'total': 4, 'status': 'Saving text file...'})
        text_filename = f"{base_name}_{unique_id}.txt"
        text_filepath = os.path.join(GENERATED_FOLDER, text_filename)
        Path(text_filepath).write_text(normalized_text, encoding="utf-8")
        return {'status': 'Success', 'filename': output_filename, 'textfile': text_filename}
    except Exception as e:
        app.logger.error(f"TTS Conversion failed in task {self.request.id}: {e}")
        self.update_state(state='FAILURE', meta={'exc_type': type(e).__name__, 'exc_message': str(e)})
        raise e

@celery.task(bind=True)
def create_audiobook_task(self, file_list, audiobook_title, audiobook_author):
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    build_dir = Path(GENERATED_FOLDER) / f"audiobook_build_{timestamp}"
    os.makedirs(build_dir, exist_ok=True)
    try:
        self.update_state(state='PROGRESS', meta={'current': 1, 'total': 4, 'status': 'Analyzing chapters...'})
        safe_paths = [Path(GENERATED_FOLDER) / secure_filename(fname) for fname in file_list]
        chapters_meta_content = f";FFMETADATA1\ntitle={audiobook_title}\nartist={audiobook_author}\n\n"
        concat_list_content = ""
        current_duration_ms = 0
        for i, path in enumerate(safe_paths):
            duration_s = MP3(path).info.length
            duration_ms = int(duration_s * 1000)
            concat_list_content += f"file '{path.name}'\n"
            chapters_meta_content += f"[CHAPTER]\nTIMEBASE=1/1000\nSTART={current_duration_ms}\nEND={current_duration_ms + duration_ms}\ntitle=Chapter {i + 1}\n\n"
            current_duration_ms += duration_ms
        concat_list_path = build_dir / "concat_list.txt"
        chapters_meta_path = build_dir / "chapters.meta"
        concat_list_path.write_text(concat_list_content)
        chapters_meta_path.write_text(chapters_meta_content)
        
        self.update_state(state='PROGRESS', meta={'current': 2, 'total': 4, 'status': 'Merging audio...'})
        temp_audio_path = build_dir / "temp_audio.aac"
        concat_command = ['ffmpeg', '-f', 'concat', '-safe', '0', '-i', str(concat_list_path), '-c:a', 'aac', '-b:a', '128k', str(temp_audio_path)]
        subprocess.run(concat_command, check=True, cwd=GENERATED_FOLDER, capture_output=True)

        self.update_state(state='PROGRESS', meta={'current': 3, 'total': 4, 'status': 'Adding chapters...'})
        output_filename = f"{secure_filename(audiobook_title)}_{timestamp}.m4b"
        output_filepath = Path(GENERATED_FOLDER) / output_filename
        mux_command = ['ffmpeg', '-i', str(temp_audio_path), '-i', str(chapters_meta_path), '-map_metadata', '1', '-codec', 'copy', str(output_filepath)]
        subprocess.run(mux_command, check=True, capture_output=True)
        
        self.update_state(state='PROGRESS', meta={'current': 4, 'total': 4, 'status': 'Cleaning up...'})
        return {'status': 'Success', 'filename': output_filename}
    except Exception as e:
        app.logger.error(f"Audiobook creation failed: {e}")
        if isinstance(e, subprocess.CalledProcessError): app.logger.error(f"FFMPEG stderr: {e.stderr.decode()}")
        raise e
    finally:
        if build_dir.exists(): shutil.rmtree(build_dir)

@app.route('/', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        if 'file' not in request.files:
            flash('No file part.', 'error')
            return redirect(request.url)
        file = request.files['file']
        if file.filename == '' or not allowed_file(file.filename):
            flash('Invalid file type.', 'error')
            return redirect(request.url)
        original_filename = secure_filename(file.filename)
        input_filepath = os.path.join(app.config['UPLOAD_FOLDER'], original_filename)
        file.save(input_filepath)
        voice_name = request.form.get("voice")
        task = convert_to_speech_task.delay(input_filepath, original_filename, voice_name)
        return render_template('result.html', task_id=task.id)
    voices = list_available_voices()
    return render_template('index.html', voices=voices)

@app.route('/files')
def list_files():
    paired_files = {}
    all_files = sorted(Path(GENERATED_FOLDER).iterdir(), key=os.path.getmtime, reverse=True)
    for entry in all_files:
        if entry.is_file() and not entry.name.startswith('sample_'):
            base_name = entry.stem
            if base_name not in paired_files:
                paired_files[base_name] = {'base_name': base_name, 'date': datetime.fromtimestamp(entry.stat().st_mtime).strftime('%Y-%m-%d %H:%M')}
            if entry.suffix in ['.mp3', '.m4b']:
                paired_files[base_name]['mp3_name'] = entry.name
            elif entry.suffix == '.txt':
                paired_files[base_name]['txt_name'] = entry.name
    audio_files = [data for data in paired_files.values() if 'mp3_name' in data]
    return render_template('files.html', audio_files=audio_files)

@app.route('/create-audiobook', methods=['POST'])
def create_audiobook():
    files_to_merge = sorted(request.form.getlist('files_to_merge'))
    audiobook_title = request.form.get('title', 'Untitled Audiobook')
    audiobook_author = request.form.get('author', 'Unknown Author')
    if not files_to_merge:
        flash("Please select at least one MP3 file.", "warning")
        return redirect(url_for('list_files'))
    task = create_audiobook_task.delay(files_to_merge, audiobook_title, audiobook_author)
    return render_template('result.html', task_id=task.id)

@app.route('/jobs')
def jobs_page():
    running_jobs, queued_jobs = [], []
    try:
        inspector = celery.control.inspect()
        active_tasks = inspector.active()
        if active_tasks:
            for worker_name, tasks in active_tasks.items():
                for task in tasks:
                    original_filename = "N/A"
                    task_args = task.get('args')
                    if task_args and isinstance(task_args, (list, tuple)) and len(task_args) > 1:
                        original_filename = Path(task_args[1]).name
                    running_jobs.append({'id': task['id'], 'name': original_filename, 'worker': worker_name})
        if redis_client:
            queued_task_messages = redis_client.lrange('celery', 0, -1)
            for message in queued_task_messages:
                try:
                    j = json.loads(message.decode('utf-8'))
                    task_id = j['headers']['id']
                    task_args = j['body'][0]
                    original_filename = Path(task_args[1]).name if len(task_args) > 1 else "N/A"
                    queued_jobs.append({'id': task_id, 'name': original_filename})
                except Exception as e:
                    app.logger.error(f"Could not parse queued task message: {e}")
    except Exception as e:
        app.logger.error(f"Could not inspect Celery/Redis: {e}")
        flash("Could not connect to the Celery worker or Redis.", "error")
    return render_template('jobs.html', running_jobs=running_jobs, queued_jobs=queued_jobs)

@app.route('/delete-bulk', methods=['POST'])
def delete_bulk():
    basenames_to_delete = set(request.form.getlist('files_to_delete'))
    if not basenames_to_delete:
        flash("No files selected for deletion.", "warning")
        return redirect(url_for('list_files'))
    deleted_count = 0
    for base_name in basenames_to_delete:
        safe_base_name = secure_filename(base_name)
        mp3_path = Path(GENERATED_FOLDER) / f"{safe_base_name}.mp3"
        txt_path = Path(GENERATED_FOLDER) / f"{safe_base_name}.txt"
        m4b_path = Path(GENERATED_FOLDER) / f"{safe_base_name}.m4b"
        if mp3_path.exists(): mp3_path.unlink(); deleted_count += 1
        if m4b_path.exists(): m4b_path.unlink(); deleted_count += 1
        if txt_path.exists(): txt_path.unlink()
    flash(f"Successfully deleted {deleted_count} file(s) and their pairs.", "success")
    return redirect(url_for('list_files'))

@app.route('/speak_sample/<voice_name>')
def speak_sample(voice_name):
    sample_text = "This is a sample of my voice."
    filename = f"sample_{Path(voice_name).stem}.mp3"
    filepath = os.path.join(GENERATED_FOLDER, filename)
    if not os.path.exists(filepath):
        try:
            tts = TTSService(voice=voice_name)
            tts.synthesize(sample_text, filepath)
        except Exception as e:
            return f"Error generating sample: {e}", 500
    return send_from_directory(app.config["GENERATED_FOLDER"], filename)

@app.route('/status/<task_id>')
def task_status(task_id):
    task = celery.AsyncResult(task_id)
    if task.state == 'PENDING':
        response = {'state': 'PENDING', 'status': {'current': 0, 'total': 4, 'status': 'Waiting...'}}
    elif task.state == 'PROGRESS':
        response = {'state': 'PROGRESS', 'status': task.info}
    elif task.state == 'SUCCESS':
        response = {'state': 'SUCCESS', 'status': task.info}
    else:
        response = {'state': task.state, 'status': str(task.info)}
    return jsonify(response)

@app.route('/generated/<name>')
def download_file(name):
    return send_from_directory(app.config["GENERATED_FOLDER"], name)
